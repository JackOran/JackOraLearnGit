#### [计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

> 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
>
> 重复出现的子串要计算它们出现的次数。
>
> 示例 1 :
>
> 输入: "00110011"
> 输出: 6
> 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
>
> 请注意，一些重复出现的子串要计算它们出现的次数。
>
> 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
> 示例 2 :
>
> 输入: "10101"
> 输出: 4
> 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
>

这个思路是这样的, 假设最简单的情况 000111, 先遍历, 前面的 0 的数量为 curr = 3, 遍历到 1 时, pre = curr 赋值为 3, 然后 curr = 1 表示现在 1 的个数, 只要 curr <= pre, 比如 curr = 1, 那么可以组成 01; curr = 2, 可以组成 0011, curr = 3, 组成 000111, 直到出现下一次 0, 然后那么 prev 就是 1 的个数, curr 表示 0001110...这个 1 后面 0 的个数, 不断重复迭代下去, 不知道我说明白没有.

```java
class Solution {
    public int countBinarySubstrings(String s) {
        int res = 0, pre = 0, cur = 1;
        for (int i = 0; i < s.length() - 1; i++){
            if (s.charAt(i) == s.charAt(i+1)){
                cur++;
            } else {
                pre = cur;
                cur = 1;
            }
            if (pre >= cur){
                res++;
            }
        }
        return res;
    }
}
```

